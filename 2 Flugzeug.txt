#include <windows.h>
#include <tchar.h>
#include <SimConnect.h>
#include <iostream>
#include <atomic>
#include <vector>
#include <cmath>

#ifndef M_PI
#define _USE_MATH_DEFINES
#include <math.h>
#endif

// Anfrage-Typen erweitern
enum DataRequests {
    REQUEST_USER_POSITION_B = 1000,
    REQUEST_USER_POSITION_N,
    REQUEST_PERIODIC_POSITION,
    REQUEST_UPDATE_AI_FLIGHT
};

// Datendefinitions-IDs
enum Definitions {
    DEFINITION_POSITION,
    DEFINITION_CONTROL // Neue Definition für Flugzeugsteuerung
};

// Struktur für Flugzeugposition
struct AircraftPosition {
    double latitude;
    double longitude;
    double altitude;
    double heading; // Flugrichtung in Grad
};

// Struktur für Flugzeugsteuerung
struct AircraftControl {
    double heading;   // Flugrichtung in Grad
    double airspeed;  // Fluggeschwindigkeit in Knoten
};

// Globale Variablen
HANDLE hSimConnect = nullptr;
std::atomic<int> spawnCount747(0);
std::atomic<int> spawnCountSmall(0);
std::vector<DWORD> aiObjectIDs; // Speichert die Object IDs der AI-Flugzeuge

// Globale Variable zum Speichern des aktuellen Heading des Spielerflugzeugs
double g_UserHeading = 0.0;

// Funktion zum Anfordern der Spielerposition für den Spawn-Vorgang (747-8F)
void RequestSpawn747() {
    HRESULT hr = SimConnect_RequestDataOnSimObject(
        hSimConnect,
        REQUEST_USER_POSITION_B,
        DEFINITION_POSITION,
        SIMCONNECT_OBJECT_ID_USER,
        SIMCONNECT_PERIOD_ONCE,
        0, 0, 0, 0
    );

    if (SUCCEEDED(hr)) {
        std::cout << "Spawn-Anfrage für 747-8F gesendet. Request ID: " << REQUEST_USER_POSITION_B << std::endl;
    }
    else {
        std::cerr << "Fehler beim Senden der Spawn-Anfrage für 747-8F. HRESULT: " << hr << std::endl;
    }
}

// Funktion zum Anfordern der Spielerposition für den Spawn-Vorgang (kleines Flugzeug)
void RequestSpawnSmall() {
    HRESULT hr = SimConnect_RequestDataOnSimObject(
        hSimConnect,
        REQUEST_USER_POSITION_N,
        DEFINITION_POSITION,
        SIMCONNECT_OBJECT_ID_USER,
        SIMCONNECT_PERIOD_ONCE,
        0, 0, 0, 0
    );

    if (SUCCEEDED(hr)) {
        std::cout << "Spawn-Anfrage für kleines Flugzeug gesendet. Request ID: " << REQUEST_USER_POSITION_N << std::endl;
    }
    else {
        std::cerr << "Fehler beim Senden der Spawn-Anfrage für kleines Flugzeug. HRESULT: " << hr << std::endl;
    }
}

// Callback-Funktion für SimConnect
void CALLBACK MyDispatchProc(SIMCONNECT_RECV* pData, DWORD cbData, void* pContext) {
    switch (pData->dwID) {
    case SIMCONNECT_RECV_ID_SIMOBJECT_DATA: {
        SIMCONNECT_RECV_SIMOBJECT_DATA* pObjData = (SIMCONNECT_RECV_SIMOBJECT_DATA*)pData;

        if (pObjData->dwRequestID == REQUEST_PERIODIC_POSITION) {
            // Periodische Anfrage: Aktuelle Position ausgeben und Heading speichern
            AircraftPosition* userPos = (AircraftPosition*)&pObjData->dwData;
            std::cout << "[Position] Breitengrad: " << userPos->latitude
                << ", Längengrad: " << userPos->longitude
                << ", Höhe: " << userPos->altitude << " ft"
                << ", Heading: " << userPos->heading << "°" << std::endl;

            // Heading des Spielerflugzeugs global speichern
            g_UserHeading = userPos->heading;
        }
        else if (pObjData->dwRequestID == REQUEST_UPDATE_AI_FLIGHT) {
            // Gewünschte Flugparameter basierend auf dem Heading des Spielerflugzeugs
            double desiredHeading = g_UserHeading-180;    // Nutze das gespeicherte Spieler-Heading
            double desiredAirspeed = 250;           // Beispiel: 500 Knoten für 747-8F
            double desiredAirspeedSmall = 120.0;      // Beispiel: 120 Knoten für ICON A5

            // Iteriere über alle AI-Flugzeuge und setze ihre Flugparameter
            for (auto aiObjectID : aiObjectIDs) {
                double airspeed = desiredAirspeed; // Hier könnte man je nach Typ unterscheiden
                double airspeedKlein = desiredAirspeedSmall;

                // Erstelle ein AircraftControl-Objekt mit den gewünschten Werten
                AircraftControl control;
                AircraftControl controlfueKlein;

                control.heading = desiredHeading;
                control.airspeed = airspeed;
                controlfueKlein.airspeed = desiredAirspeedSmall;
                // Setze die Daten auf dem AI-Flugzeug
                HRESULT hrSet = SimConnect_SetDataOnSimObject(
                    hSimConnect,
                    DEFINITION_CONTROL,
                    aiObjectID,
                    SIMCONNECT_DATA_SET_FLAG_DEFAULT,
                    0,
                    sizeof(AircraftControl),
                    &control
                );

                if (FAILED(hrSet)) {
                    std::cerr << "Fehler beim Setzen der Flugsteuerungsdaten für AI-Flugzeug ID " << aiObjectID << ". HRESULT: " << hrSet << std::endl;
                }
            }
        }

        // Handle Spawn Requests
        if (pObjData->dwRequestID == REQUEST_USER_POSITION_B) {
            // Spielerposition erhalten
            AircraftPosition* userPos = (AircraftPosition*)&pObjData->dwData;

            // Spielerheading in Radiant
            double headingRad = (userPos->heading * M_PI) / 180.0;

            // Wir wollen das AI-Flugzeug direkt vor uns platzieren, 
            // damit es auf uns zufliegt. offsetDistance ~0.001 grad ~100m
            double offsetDistance = 0.009;
            double spawnLat = userPos->latitude + (offsetDistance * cos(headingRad));
            double spawnLon = userPos->longitude + (offsetDistance * sin(headingRad));

           
            double oppositeHeading = fmod(userPos->heading, 360.0);

            SIMCONNECT_DATA_INITPOSITION InitPos747;
            InitPos747.Latitude = spawnLat;
            InitPos747.Longitude = spawnLon;
            InitPos747.Altitude = userPos->altitude + 1;
            InitPos747.Pitch = 0.0;
            InitPos747.Bank = 0.0;
            InitPos747.Heading = userPos->heading-100;
            InitPos747.OnGround = 0;
            InitPos747.Airspeed = 150;

            HRESULT hr = SimConnect_AICreateNonATCAircraft(
                hSimConnect,
                "747-8F",
                "AI747",
                InitPos747,
                0
            );

            if (SUCCEEDED(hr)) {
                spawnCount747++;
                std::cout << "AI-Flugzeug (747-8F) erstellt! Gesamt: " << spawnCount747.load() << std::endl;
            }
            else {
                std::cerr << "Fehler beim Erstellen des AI-Flugzeugs (747-8F). HRESULT: " << hr << std::endl;
            }
        }
        else if (pObjData->dwRequestID == REQUEST_USER_POSITION_N) {
            // Spielerposition erhalten
            AircraftPosition* userPos = (AircraftPosition*)&pObjData->dwData;

            // Spielerheading in Radiant
            double headingRad = (userPos->heading * M_PI) / 180.0;

            // Flugzeug vor dem Spieler platzieren
            double offsetDistance = 0.001;
            double spawnLat = userPos->latitude + (offsetDistance * cos(headingRad));
            double spawnLon = userPos->longitude + (offsetDistance * sin(headingRad));

            // Heading um 180 Grad drehen, damit es auf dich zufliegt
            double oppositeHeading = fmod(userPos->heading + 180.0, 360.0);

            SIMCONNECT_DATA_INITPOSITION InitPosICON;
            InitPosICON.Latitude = spawnLat;
            InitPosICON.Longitude = spawnLon;
            InitPosICON.Altitude = userPos->altitude + 1;
            InitPosICON.Pitch = 0.0;
            InitPosICON.Bank = 0.0;
            InitPosICON.Heading = oppositeHeading;
            InitPosICON.OnGround = 0;
            InitPosICON.Airspeed = 120;

            HRESULT hr = SimConnect_AICreateNonATCAircraft(
                hSimConnect,
                "Icon A5",
                "AIICON",
                InitPosICON,
                0
            );

            if (SUCCEEDED(hr)) {
                spawnCountSmall++;
                std::cout << "AI-Flugzeug (Icon A5) erstellt! Gesamt: " << spawnCountSmall.load() << std::endl;
            }
            else {
                std::cerr << "Fehler beim Erstellen des AI-Flugzeugs (Icon A5). HRESULT: " << hr << std::endl;
            }
        }
        break;
    }
    case SIMCONNECT_RECV_ID_ASSIGNED_OBJECT_ID: {
        SIMCONNECT_RECV_ASSIGNED_OBJECT_ID* pAssigned = (SIMCONNECT_RECV_ASSIGNED_OBJECT_ID*)pData;
        std::cout << "AI-Flugzeug ID zugewiesen: " << pAssigned->dwObjectID << std::endl;
        aiObjectIDs.push_back(pAssigned->dwObjectID); // Speichere die Object ID
        break;
    }
    case SIMCONNECT_RECV_ID_QUIT: {
        std::cout << "SimConnect beendet." << std::endl;
        SimConnect_Close(hSimConnect);
        exit(0);
    }
    default:
        break;
    }
}

// Fensterprozedur zur Verarbeitung von Hotkey-Eingaben
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
    switch (uMsg) {
    case WM_HOTKEY:
        if (wParam == 1) { // Hotkey ID 1 (Taste "b")
            RequestSpawn747();
        }
        else if (wParam == 2) { // Hotkey ID 2 (Taste "n")
            RequestSpawnSmall();
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;
    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}

int main() {
    // Registriere ein unsichtbares Fenster
    const wchar_t CLASS_NAME[] = L"SimConnectHotkeyWindow";

    WNDCLASS wc = { };
    wc.lpfnWndProc = WindowProc;
    wc.hInstance = GetModuleHandle(NULL);
    wc.lpszClassName = CLASS_NAME;

    if (!RegisterClass(&wc)) {
        std::cerr << "Fensterklasse konnte nicht registriert werden. Fehler: " << GetLastError() << std::endl;
        return 1;
    }

    HWND hwnd = CreateWindowEx(
        0, CLASS_NAME, L"SimConnectHotkeyWindow", 0,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, GetModuleHandle(NULL), NULL
    );

    if (!hwnd) {
        std::cerr << "Fenster konnte nicht erstellt werden. Fehler: " << GetLastError() << std::endl;
        return 1;
    }

    // Registriere den Hotkey für "b" (0x42) und "n" (0x4E)
    // Alt + n Drücken!! 
    if (!RegisterHotKey(hwnd, 1, MOD_ALT, 0x42)) { // "b"
        std::cerr << "Hotkey 'b' konnte nicht registriert werden. Fehler: " << GetLastError() << std::endl;
        return 1;
    }

    if (!RegisterHotKey(hwnd, 2, MOD_ALT, 0x4E)) { // "n"
        std::cerr << "Hotkey 'n' konnte nicht registriert werden. Fehler: " << GetLastError() << std::endl;
        return 1;
    }

    // Verbindung zu SimConnect herstellen
    HRESULT hr = SimConnect_Open(&hSimConnect, "AI Aircraft Spawner", hwnd, WM_USER, 0, 0);
    if (FAILED(hr)) {
        std::cerr << "Verbindung zu SimConnect konnte nicht hergestellt werden. HRESULT: " << hr << std::endl;
        return 1;
    }

  
    hr = SimConnect_AddToDataDefinition(hSimConnect, DEFINITION_POSITION, "PLANE LATITUDE", "degrees");
    hr = SimConnect_AddToDataDefinition(hSimConnect, DEFINITION_POSITION, "PLANE LONGITUDE", "degrees");
    hr = SimConnect_AddToDataDefinition(hSimConnect, DEFINITION_POSITION, "PLANE ALTITUDE", "feet");
    hr = SimConnect_AddToDataDefinition(hSimConnect, DEFINITION_POSITION, "PLANE HEADING DEGREES TRUE", "degrees");

   
    hr = SimConnect_AddToDataDefinition(hSimConnect, DEFINITION_CONTROL, "PLANE HEADING DEGREES TRUE", "degrees");
    hr = SimConnect_AddToDataDefinition(hSimConnect, DEFINITION_CONTROL, "AIRSPEED INDICATED", "knots");

    // Periodische Abfrage für die Position des Flugzeugs alle 5 Sekunden  Funktioniert nicht wie es soll ;D 
    hr = SimConnect_RequestDataOnSimObject(
        hSimConnect,
        REQUEST_PERIODIC_POSITION,
        DEFINITION_POSITION,
        SIMCONNECT_OBJECT_ID_USER,
        SIMCONNECT_PERIOD_SECOND,
        0,
        5,
        0, 0
    );

    // Zusätzliche periodische Anfrage für das Update der AI-Flugzeuge 
    hr = SimConnect_RequestDataOnSimObject(
        hSimConnect,
        REQUEST_UPDATE_AI_FLIGHT,
        DEFINITION_CONTROL,
        SIMCONNECT_OBJECT_ID_USER,
        SIMCONNECT_PERIOD_SECOND,
        0,
        1,
        0, 0
    );

    // Nachrichten-Schleife
    MSG msg = { };
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        SimConnect_CallDispatch(hSimConnect, MyDispatchProc, NULL);
    }

    // Hotkeys deregistrieren und SimConnect schließen
    UnregisterHotKey(hwnd, 1);
    UnregisterHotKey(hwnd, 2);
    SimConnect_Close(hSimConnect);

    return 0;
}
